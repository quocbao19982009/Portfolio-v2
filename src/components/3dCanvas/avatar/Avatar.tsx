/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useAnimations, useFBX, useGLTF } from '@react-three/drei';
import { GroupProps, useFrame } from '@react-three/fiber';
import { GUI } from 'dat.gui';
import { useControls } from 'leva';
import React from 'react';
import * as THREE from 'three';
import { Group } from 'three';

const Avatar = (props: GroupProps) => {
    const ref = React.useRef<Group | null>(null);
    const { nodes, materials } = useGLTF('models/658ea6f4d729e67ab0848b4a.glb');

    const { headFollow, cursorFollow } = useControls({
        headFollow: true,
        cursorFollow: true,
    });
    const animation = useFBX('animation/Waving.fbx');
    const waving = animation.animations;
    waving[0].name = 'waving';
    console.log('waving', waving);
    const { actions } = useAnimations(waving, ref);
    console.log('actions', actions);

    React.useEffect(() => {
        const gui = new GUI();
        if (!ref.current) return;
        gui.add(ref.current.rotation, 'x', 0, Math.PI * 2).name('rotationX');
        gui.add(ref.current.rotation, 'y', 0, Math.PI * 2).name('rotationY');
        gui.add(ref.current.rotation, 'z', 0, Math.PI * 2).name('rotationZ');
        gui.add(ref.current.position, 'x', -10, 10).name('positionX');
        gui.add(ref.current.position, 'y', -10, 10).name('positionY');
        gui.add(ref.current.position, 'z', -10, 10).name('positionZ');
        return () => {
            gui.destroy();
        };
    }, []);

    if (ref.current) {
        // Use 'head' variable here if needed
    }

    const getMouseDegrees = (x: number, y: number, degreeLimit: number) => {
        let dx = 0,
            dy = 0,
            xdiff,
            xPercentage,
            ydiff,
            yPercentage;

        let w = { x: window.innerWidth, y: window.innerHeight };

        // Left (Rotates neck left between 0 and -degreeLimit)

        // 1. If cursor is in the left half of screen
        if (x <= w.x / 2) {
            // 2. Get the difference between middle of screen and cursor position
            xdiff = w.x / 2 - x;
            // 3. Find the percentage of that difference (percentage toward edge of screen)
            xPercentage = (xdiff / (w.x / 2)) * 100;
            // 4. Convert that to a percentage of the maximum rotation we allow for the neck
            dx = ((degreeLimit * xPercentage) / 100) * -1;
        }
        // Right (Rotates neck right between 0 and degreeLimit)
        if (x >= w.x / 2) {
            xdiff = x - w.x / 2;
            xPercentage = (xdiff / (w.x / 2)) * 100;
            dx = (degreeLimit * xPercentage) / 100;
        }
        // Up (Rotates neck up between 0 and -degreeLimit)
        if (y <= w.y / 2) {
            ydiff = w.y / 2 - y;
            yPercentage = (ydiff / (w.y / 2)) * 100;
            // Note that I cut degreeLimit in half when she looks up
            dy = ((degreeLimit * 0.5 * yPercentage) / 100) * -1;
        }

        // Down (Rotates neck down between 0 and degreeLimit)
        if (y >= w.y / 2) {
            ydiff = y - w.y / 2;
            yPercentage = (ydiff / (w.y / 2)) * 100;
            dy = (degreeLimit * yPercentage) / 100;
        }
        return { x: dx, y: dy };
    };

    function getMousePos(e: MouseEvent) {
        return { x: e.clientX, y: e.clientY };
    }
    const head = ref.current?.getObjectByName('Head');

    function moveJoint(mouse, joint, degreeLimit) {
        let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
        console.log('degrees', degrees);
        joint.rotation.y = THREE.MathUtils.degToRad(degrees.x);
        joint.rotation.x = THREE.MathUtils.degToRad(degrees.y);
    }

    // document.addEventListener('mousemove', function (e) {
    //     console.log('mouse move');
    //     const mousecoords = getMousePos(e);
    //     if (head) {
    //         moveJoint(mousecoords, head, 30);
    //     }
    // });

    useFrame((state) => {
        // Follow mouse but cannot turn too m
        const target = new THREE.Vector3(state.pointer.x, state.pointer.y, 0);
        const head = ref.current?.getObjectByName('Head');
        if (head) {
            head.rotation.y = Math.max(-0.5, Math.min(0.5, target.x));
            // head.rotation.x = Math.max(-0.5, Math.min(0.5, -target.y));

            head.rotation.x = Math.max(-0.5, Math.min(0.1, -target.y));
        }

        // ref.current?.getObjectByName('Head')?.rotation.y =
        //     THREE.MathUtils.degToRad(degrees.y);
    });
    return (
        <group {...props} ref={ref} dispose={null}>
            <group>
                <primitive object={nodes.Hips} />
                <skinnedMesh
                    geometry={nodes.Wolf3D_Body.geometry}
                    material={materials.Wolf3D_Body}
                    skeleton={nodes.Wolf3D_Body.skeleton}
                />
                <skinnedMesh
                    geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
                    material={materials.Wolf3D_Outfit_Bottom}
                    skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
                />
                <skinnedMesh
                    geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
                    material={materials.Wolf3D_Outfit_Footwear}
                    skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
                />
                <skinnedMesh
                    geometry={nodes.Wolf3D_Outfit_Top.geometry}
                    material={materials.Wolf3D_Outfit_Top}
                    skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
                />
                <skinnedMesh
                    geometry={nodes.Wolf3D_Hair.geometry}
                    material={materials.Wolf3D_Hair}
                    skeleton={nodes.Wolf3D_Hair.skeleton}
                />
                <skinnedMesh
                    name="EyeLeft"
                    geometry={nodes.EyeLeft.geometry}
                    material={materials.Wolf3D_Eye}
                    skeleton={nodes.EyeLeft.skeleton}
                    morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
                    morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
                />
                <skinnedMesh
                    name="EyeRight"
                    geometry={nodes.EyeRight.geometry}
                    material={materials.Wolf3D_Eye}
                    skeleton={nodes.EyeRight.skeleton}
                    morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
                    morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
                />
                <skinnedMesh
                    name="Wolf3D_Head"
                    geometry={nodes.Wolf3D_Head.geometry}
                    material={materials.Wolf3D_Skin}
                    skeleton={nodes.Wolf3D_Head.skeleton}
                    morphTargetDictionary={
                        nodes.Wolf3D_Head.morphTargetDictionary
                    }
                    morphTargetInfluences={
                        nodes.Wolf3D_Head.morphTargetInfluences
                    }
                />
                <skinnedMesh
                    name="Wolf3D_Teeth"
                    geometry={nodes.Wolf3D_Teeth.geometry}
                    material={materials.Wolf3D_Teeth}
                    skeleton={nodes.Wolf3D_Teeth.skeleton}
                    morphTargetDictionary={
                        nodes.Wolf3D_Teeth.morphTargetDictionary
                    }
                    morphTargetInfluences={
                        nodes.Wolf3D_Teeth.morphTargetInfluences
                    }
                />
            </group>
        </group>
    );
};

useGLTF.preload('models/658ea6f4d729e67ab0848b4a.glb');

export default Avatar;
